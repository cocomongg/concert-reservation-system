# 트랜잭션 범위 분석 및 MSA에서의 트랜잭션 처리
## 목차
1. **개요**
2. **기존 시스템의 트랜잭션 범위 분석**
   - 기존 트랜잭션 범위의 문제점
   - 해결방안
3. **서비스 규모 확장에 따른 설계**
   - MSA란?  
   - 서비스 분리
4. **분산 트랜잭션**
   - 분산환경에서의 트랜잭션 처리 한계
   - 해결방안
5. **결론**
<br/>

## 1. 개요
- 현재 시스템의 트랜잭션 처리 범위를 분석하고, 발생할 수 있는 문제점과 개선 방안을 다룬다.
- 서비스 확장에 따라 마이크로서비스 아키텍처(MSA)로 전환하기 위해 서비스 분리 설계를 진행한다.
- 서비스 분리에 의해 발생하는 분산 환경에서의 트랜잭션 처리 한계와 이를 해결하기 위한 방법을 다룬다.
<br/>

## 2. 기존 시스템의 트랜잭션 범위 분석
### 사용자 잔액 충전/사용
  ```java
  충전/사용_TX() {
    사용자_조회();
    사용자_잔액_충전/사용();
  }
  ```

### 콘서트 좌석 예약
  ```java
  좌석예약_TX() {
    사용자_조회();
    콘서트_좌석_임시_배정();
    콘서트_예약_생성();
  }
  ```

### 결제
  ```java
  결제_TX() {
    콘서트_예약_조회();
    콘서트_좌석_임시_배정_검증();
    사용자_잔액_사용();
    콘서트_예약_확정_처리();
    결제_저장();
    결제_이력_저장();
    대기열_토큰_만료_처리();
    알림_결제_완료();
  }
  ```

### 2-1. 기존 트랜잭션 범위의 문제점
- 현재 시스템을 기준으로 트랜잭션 범위가 가장 넓은 로직은 **결제** 이다. 트랜잭션 범위가 넓을 때 발생할 수 있는 문제는 아래와 같다.

#### 시스템 성능 저하
-  넓은 범위의 트랜잭션으로 인해 데이터베이스 커넥션이 오래 유지되어, 시스템의 성능을 저하시킬 수 있다.
   - `알림_결제_완료()`와 같이 외부 서버와 통신하는 과정에서 오래 걸릴 경우, 전체 트랜잭션에 영향을 끼치고, 성능 저하가 발생할 가능성이 있다.  
#### 부가 로직의 오류로 인한 롤백
- 주요 로직의 처리가 성공적으로 이뤄져도, 부가 로직의 오류로 인해 롤백이 되어, 주요 로직의 실패 처리로 이뤄진다.
  - 결제의 주요 로직이 아닌, `결제_이력_저장()`, `대기열_토큰_만료_처리()`, `알림_결제_완료()` 이 세개의 로직 중 하나라도 오류가 발생하면 transaction rollback으로 인해 결제가 실패된다.
#### 확장성의 어려움
- 한 트랜잭션안에 다양한 서비스(사용자, 콘서트예약, 콘서트좌석, 대기열, 결제)가 몰려있고, 이로 인해 각 서비스 확장에 대한 복잡성을 증가시킬 수 있다.
  - 콘서트 혹은 사용자 서비스의 확장으로 인해 결제 트랜잭션에 영향을 끼칠 수 있다.
<br/>

### 2-2. 해결방안
- 문제가 되는 트랜잭션의 넓은 범위를 좁히기 위해 **이벤트 기반의 처리**를 통해 서비스(트랜잭션)를 분리할 수 있다.

#### Spring Event
- 이벤트를 기반으로 한 서비스 간의 통신을 통해 트랜잭션의 범위를 좁힐 수 있다.
- Spring에서 제공하는 `ApplicationEventPublisher`를 통해 이벤트를 발행하고, `@TransactionalEventListener`를 통해 특정 이벤트를 구독할 수 있다.

#### Spring Event 적용 예시
- #### 이벤트 발행
```java
@RequiredArgsConstructor
@Component
public class PaymentFacade {
    // .. 생략
    private final DomainEventPublisher eventPublisher;

    @Transactional
    public PaymentInfo payment(Long reservationId, String token, LocalDateTime dateTime) {
        // .. 생략 (기존 결제 처리 로직)
        // 결제 완료 알림 전송 이벤트 발행
        eventPublisher.publish(new SendNotificationEvent("결제 완료", "결제가 완료되었습니다.", memberId));

        return new PaymentInfo(payment);
    }
}
```

- #### 이벤트 구독
```java
@RequiredArgsConstructor
@Component
public class NotificationEventHandler {

    private final NotificationService notificationService;

    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void handlePaymentDoneEvent(SendNotificationEvent event) {
         //.. 생략
         notificationService.sendNotification(message);
    }
}
```

#### 이벤트 기반 처리의 장점
- 시스템 성능의 향상을 기대할 수 있다.
  - EventListener에 `@Async` 어노테이션을 적용하여 부가 로직을 비동기로 처리할 수 있다.
- 트랜잭션의 범위를 좁힐 수 있다.
  - `TransactionPhase.AFTER_COMMIT`을 통해 기존 주요 로직의 트랜잭션에서 부가 로직을 분리할 수 있다.
- 확장성이 용이하다.
  - 서비스간 이벤트 기반 통신으로 인해 각 서비스의 결합을 낮출 수 있다.
<br/>

## 3. 서비스 규모 확장에 따른 설계
이벤트 기반의 처리를 통해 넓은 트랜잭션 범위로 인한 문제를 해결하고, 각 서비스의 확장성을 용이하게 만들었다. 하지만 서비스의 규모가 확장될수록 현재 시스템 구조인 모놀리식 아키텍처에서는 여전히 확장에 어려움이 있을 수 있다.
이를 해결하기 위해 마이크로서비스 아키텍처(MSA) 도입을 고려해볼 수 있다.

### 3-1. MSA 란?
MSA는 하나의 애플리케이션을 여러 개의 독립적인 서비스로 분리하여 개발하고 배포하는 방식이다.
#### 특징
-  서비스 간 통신은 REST API/gRPC를 통해 동기적으로 이뤄지거나 메시지큐 등을 통해 비동기적으로 이뤄진다.
-  서비스는 독립적으로 배포 및 확장이 가능하며, 특정 서비스만 업데이트 할 수 있다.
#### 장점
- 장애가 발생해도, 다른 서비스에 직접적인 영향을 미치지 않아 시스템 안정성이 높아진다.
- 서비스 별 독립적인 운영을 통해, 생산성과 유지보수성이 높아진다.
- 서비스 별 자원을 다르게 할당하여, 효율적으로 자원을 관리할 수 있다.
#### 단점
- 운영에 대한 복잡도가 높아질 수 있다.
- 서비스 간 통신으로 인해 네트워크 비용이 발생한다.
- 분산된 트랜잭션으로 인해 데이터 일관성을 유지하는데 어려움이 발생할 수 있다.
<br/>

### 3-2. MSA 도입을 위한 서비스 분리
MSA로 전환하기 위해 기존 시스템을 바탕으로 아래와 같이 서비스를 분리할 수 있다.

#### Member Service
- 기능: 사용자 관리, 사용자 포인트 관리
#### WaitingQueue Service
- 기능: 대기열 관리
#### Concert Service
- 기능: 콘서트 관련(스케줄, 좌석, 예약) 관리
#### Payment Service
- 기능: 결제 관리
<br/>

## 4. 분산 트랜잭션
MSA로 인해 서비스는 분리되고, 각 서비스마다 다른 데이터베이스를 사용한다. 이러한 분산 환경에서의 트랜잭션 처리는 데이터의 일관성을 유지하는데 한계가 존재한다.

### 4-1. 분산 환경에서의 트랜잭션 처리 한계
#### 데이터 일관성 유지의 어려움
- 서비스가 분리되어 있고, 각 서비스에서 사용하는 데이터베이스가 달라, 데이터의 일관성을 유지하는데 어려움이 있다.
#### 네트워크 지연 이슈
- 서비스 간 통신이 네트워크를 통해서 이뤄져, 네트워크 지연 시 트랜잭션의 일부분만 커밋되고, 일부분은 롤백되어 데이터 불일치가 발생할 수 있다.
#### 트랜잭션 관리의 복잡성
- 분산된 환경에서의 트랜잭션 관리의 복잡성이 높다.
<br/>

### 4-2. 해결방안
#### Saga Pattern
- **연속된 각 서비스의 로컬 트랜잭션이 이어져, 비지니스의 전체 트랜잭션을 구성**한다.
  -  1번째 트랜잭션이 완료되면, 2번째 트랜잭션이 트리거 되고, 2번째 트랜잭션이 완료되면 그 다음 트랜잭션이 트리거되어 실행된다.
- 로컬 트랜잭션이 실패했을 경우, **보상 트랜잭션**을 발생시켜 데이터 일관성을 유지한다.
  - 데이터의 일관성을 애플리케이션에서 관리한다. 

#### Choreography Saga
- 특징
  - 각 서비스는 트랜잭션이 완료되면, 완료 이벤트를 발행한다. 그 다음에 수행되어야할 로컬 트랜잭션에서 해당 이벤트를 구독하여 실행한다.
  - 중간에 로컬 트랜잭션이 실패하면, 보상 트랜잭션 이벤트를 발행하여 이전 로컬 트랜잭션의 롤백 처리를 한다.
- 장점
  - 구성이 편리하다
- 단점
  - 비지니스 로직에 포함되는 로컬 트랜잭션이 많을 수록 흐름이 복잡해진다.
  - 각 서비스가 서로를 알고 있는 구조로, 결합도가 높다.  

#### Orchestration Saga
- 특징
  - 중앙 집중된 Saga Orchestrator가 전체 트랜잭션을 관리하여, 각 서비스한테 어떤 로컬 트랜잭션을 실행해야 하는지 알려주는 방식이다.
  - 필요하다면 보상 트랜잭션 이벤트를 발행하여 트랜잭션 롤백 처리를 한다.
- 장점
  - Orchestrator가 전체 트랜잭션을 관리하기 때문에, 트랜잭션 흐름이 명확하다.
  - 각 서비스가 서로 알지 못하는 구조로, 결합도가 낮다.
- 단점
  - Orchestrator가 단일 장애 지점(SPOF)가 될 수 있다.

#### OutBox Pattern
- 특징
  - 서비스 로직의 실행과 그 이후의 이벤트 발행을 원자적으로 함께 실행할 수 있게 한다.
  - 발행할 이벤트를 데이터베이스 OutBox테이블에 저장하고, 별도의 프로세스가 테이블을 지속적으로 확인하여 메세지 브로커로 이벤트를 전송한다.
  - 해당 서비스의 로직이 실패하면 같은 트랜잭션안에 있기 때문에 이벤트도 롤백으로 인해 저장되지 않게 되어, 일관성을 유지할 수 있다.
- 장점
  - 트랜잭션의 일관성을 유지할 수 있다.
- 단점
  - 이벤트를 저장하기 위한 추가적인 저장 공간이 필요하다.
 
#### Saga패턴 + OutBox 패턴
두 패턴을 결합하여 사용함으로써, 데이터의 일관성과 안정성을 더 높일 수 있다. <br/>
Saga패턴에서 분산 트랜잭션을 관리하기 위해 각 서비스에서 이벤트를 발행할 때, OutBox패턴을 곁들임으로써 이벤트 발행의 신뢰성을 더 높일 수 있다.

#### Saga패턴 + OutBox 패턴을 적용하여 결제 프로세스 설계
1. `PaymentSagaOrchestrator`
   - 결제 요청을 수신하고, 콘서트 예약 조회 및 검증을 위해 `CheckReservationEvent` 발행
<br/>

2. `ConcertService`
   - `CheckReservationEvent` 수신
   - 예약 정보 조회 및 좌석 임시 상태 검증 로직 수행
   - OutBox테이블에 `UseMemberPointEvent` 저장
   - OutBox테이블에 저장된 `UseMemberPointEvent`를 메시지 브로커로 전송 (별도 프로세스를 통해 전송)
<br/>

3. `PointService`
   - `UseMemberPointEvent` 수신
   - 사용자 포인트 차감 로직 수행
   - 사용자 포인트가 업데이트될 때, OutBox테이블에 `CofirmConcertReservationEvent` 저장
   - OutBox 테이블에 저장된 `ConfirmConcertReservationEvent`를 메시지 브로커로 전송 (별도 프로세스를 통해 전송).
<br/>

4. `ConcertService`
   - `CofirmConcertReservationEvent` 수신
   - 콘서트 예약 확정 로직 수행
   - 콘서트 예약 상태가 업데이트 될 때, OutBox테이블에 `CreatePaymentEvent` 저장
   - OutBox테이블에 저장된 `CreatePaymentEvent`를 메시지 브로커로 전송 (별도 프로세스를 통해 전송)
<br/>

5. `PaymentService`
   - `CreatePaymentEvent` 수신
   - 결제 정보/이력 생성 로직 수행
   - 결제 정보/이력이 저장될 때, OutBox테이블에 `ExpireTokenEvent` 저장
   - OutBox테이블에 저장된 `ExpireTokenEvent`를 메시지 브로커로 전송 (별도 프로세스를 통해 전송)
<br/>

6. `WaitingQueueService`
    - `ExpireTokenEvent` 수신
    - 대기열 토큰 만료 로직 수행
    - 토큰 상태가 업데이트될 때, Outbox테이블에 `PaymentSagaCompletedEvent` 저장
    - OutBox테이블에 저장된 `PaymentSagaCompletedEvent`를 메시지 브로커로 전송 (별도 프로세스를 통해 전송)
<br/>

7. `PaymentSagaOrchestrator`
    - `PaymentSagaCompletedEvent` 수신
    - Saga 완료 처리 로직 수행
  
## 5. 결론
다양한 경우에서 트랜잭션으로 인해 발생할 수 있는 문제와 해결방안에 대해 살펴봤다. 트랜잭션의 범위를 넓게 잡았을 경우, Event기반의 처리를 통해 부가적인 로직을 트랙잭션으로 부터 분리했다.
분산 환경에서의 트랜잭션의 경우 다양한 패턴을 통해 한계를 극복하고, 데이터의 일관성을 유지할 수 있는 방법들에 대해서 다뤘다. 그 중 Saga Pattern과 OutBox Pattern를 같이 사용하면 더욱 효과적으로 분산 환경에서 트랜잭션을 처리할 수 있을 것이다.
