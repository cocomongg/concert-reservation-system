# 동시성 제어 방식 비교 분석
<br/>

## 1. 동시성 이슈 발생 시나리오

### (1) 좌석 예약
- 동시에 여러 사용자가 하나의 좌석을 예약할 때, 1명만 해당 좌석을 예약할 수 있어야 한다.

#### 동시성 문제 발생 원인
- 여러 사용자가 동시에 같은 좌석을 예약하려고 시도할 때, 중복 예약이 발생할 수 있다.
- 예약 처리에 대한 트랜잭션 커밋을 하기 전에 다른 트랜잭션에서 해당 좌석이 이미 예약된 상태가 아니기 때문에 중복 예약이 발생할 수 있다.

#### 기대 결과
- 동시성 문제가 발생하는 좌석에 대해 예약 처리가 완료된 사용자만 해당 좌석을 성공적으로 예약한다.
- 이후 다른 사용자들의 해당 좌석 예약 시도는 실패하고, 이미 예약된 좌석임을 나타내는 메시지를 응답해야 한다.

### (2) 포인트 충전
- 동시에 한 명의 사용자에 대한 포인트 충전이 발생할 때, 충전한 만큼 포인트가 정확하게 증가되어야 한다.
  - 예: 관리자의 포인트 지급과 사용자의 포인트 충전 행위가 동시에 발생할 경우

#### 동시성 문제 발생 원인
- 여러 요청으로 동시에 같은 사용자의 포인트를 충전하려고 시도할 때, **Lost Update** 문제가 발생할 수 있다.
- 각 요청이 동시에 사용자의 잔액을 조회하고 포인트를 증가시키기 때문에, 전체 요청된 충전 금액이 정확하게 반영되지 않을 수 있다.

#### 기대 결과
- 동시에 같은 사용자의 포인트를 충전하는 요청이 발생할 때, 모든 충전 요청이 정확히 반영되어 포인트가 누락 없이 증가되어야 한다.

### (3) 포인트 사용
- 동시에 한 명의 사용자에 대한 포인트 사용이 발생할 때, 사용한 만큼 포인트가 정확하게 차감되어야 한다.
- 한 명의 사용자가 여러 예약 건에 대해 동시에 결제 요청을 할 때, 총 결제 금액만큼 포인트가 정확하게 차감되어야 한다.

#### 동시성 문제 발생 원인
- 동시에 같은 사용자의 포인트를 사용하려고 시도할 때, **Lost Update** 문제가 발생할 수 있다.
- 각 요청이 동시에 사용자의 잔액을 조회하고 포인트를 차감시키기 때문에, 전체 요청된 사용 금액이 정확하게 반영되지 않을 수 있다.

#### 기대 결과
- 동시에 발생한 포인트 사용 요청이 모두 정확히 처리되어, 포인트 잔액이 올바르게 차감되어야 한다.
- 만약 포인트 잔액이 부족한 경우, 적절한 오류 메시지를 반환하여 포인트 사용을 제한해야 한다.

### (4) 결제
- 동시에 같은 예약 건에 대해 결제 요청이 발생했을 때, 단 한 번의 결제만 이루어져야 한다.

#### 동시성 문제 발생 원인
- 예약 완료 처리에 대한 트랜잭션 커밋을 하기 전에 다른 트랜잭션에서 해당 예약 건이 이미 결제 완료 상태가 아니기 때문에 중복 결제가 발생할 수 있다.

#### 기대 결과
- 동일한 예약 건에 대해 단 하나의 결제만 성공적으로 처리되어야 한다.
- 중복 결제 시도는 실패하고, 이미 결제가 완료된 예약임을 나타내는 메시지를 응답해야 한다.


## 2. 동시성 제어 방식
### (1) Optimistic Lock
#### 동작 방식
- 읽기나 쓰기를 차단하지 않고, 업데이트 시점에 데이터의 버전이나 타임스탬프를 검증하여 충돌을 감지한다.<br/> 
  애플리케이션 레벨에서 구현되며, 데이터베이스가 직접 제공하는 락락 방식은 아니다.

#### 장점
- 디비 락이 아니기 때문에 디비에 부하가 적다.

#### 단점
- 충돌이 발생할 경우, 롤백 후 재시도 로직으로 인해 성능 저하가 발생할 수 있다.
<br/>
<br/>

<details>
  <summary>테스트 결과</summary>

#### [좌석 예약]
- 재시도 설정 x<br/>
![스크린샷 2024-11-01 오전 6 15 26](https://github.com/user-attachments/assets/2136e5ba-d8bb-4ca8-b1f6-aa29e32910ce)
<br/>
- 재시도 설정 o <br/>
![스크린샷 2024-11-01 오전 4 49 32](https://github.com/user-attachments/assets/b1ca8957-6709-4a7b-ae38-78888be09c40)
#### [포인트 충전]
![스크린샷 2024-11-01 오전 6 14 29](https://github.com/user-attachments/assets/dfe5f3b4-23b6-40bd-90ec-1a2f4bcf0039)
#### [다른 예약 같은 유저 동시 결제(포인트 사용)]
![스크린샷 2024-11-01 오전 6 16 37](https://github.com/user-attachments/assets/5a2f320d-23a5-426f-9eb9-16b789841f10)
#### [같은 예약 동시 결제]
![스크린샷 2024-11-01 오전 6 16 00](https://github.com/user-attachments/assets/1d65c6dd-be5d-4d96-a507-0607726d16e6)
</details>
<br/>

### 결과 분석 및 정리
- 좌석 예약 같은 경우는 한번만 성공하면 되기 때문에 재시도 설정을 할 필요가 없다.
- 포인트 충전, 포인트 사용, 결제 같은 경우는 재시도 설정을 통해 성공할 때까지 재시도를 하도록 설정해야 한다.
- 재시도를 설정함으로써 디비에 부하가 많이 가게 되고, 네트워크 통신 등이 자주 발생하여 성능 저하가 발생할 수 있다.
- [다른 예약 같은 유저 동시 결제(포인트 사용)] 시나리오 같은 경우 결제 로직을 전부 실행하기 때문에 가장 오래걸린다.
  - [같은 예약 동시 결제] 시나리오 같은 경우 좌석 결제 여부를 검사하여 예외처리를 하기 때문에 좀 더 빠르게 처리된다. 
- 재시도 로직을 필요로 하지 않는 동시성 제어에서 유용하게 사용할 수 있으며, 해당 경우에는 스레드의 대기를 유발하는 비관적락에 비해 성능 저하를 덜 유발 시킬 수 있다.

<br/>

### (2) Pessimistic Lock
#### 동작 방식
- 데이터의 읽기나 쓰기를 차단하여 동시 접근을 막고, 하나의 트랜잭션만 해당 데이터에 접근할 수 있도록 한다.<br/>
  데이터베이스가 제공하는 락 메커니즘을 사용한다.

#### 장점
- 데이터 충돌을 사전에 방지하여 데이터의 일관성을 보장한다. 

#### 단점
- 대용량 트래픽이 발생 시 디비에 부하가 많이 가며, 성능 저하가 발생할 수 있다.
<br/>
<br/>

<details>
  <summary>테스트 결과</summary>

#### [좌석 예약]
![스크린샷 2024-11-01 오전 4 55 30](https://github.com/user-attachments/assets/028fe513-4655-47c4-a8c7-291de416294b)
#### [포인트 충전]
![스크린샷 2024-11-01 오전 4 54 46](https://github.com/user-attachments/assets/1c3f7622-cb07-44db-b1c5-5958e6f0b12d)
#### [포인트 사용]
![스크린샷 2024-11-01 오전 4 56 24](https://github.com/user-attachments/assets/23238390-f87f-4064-b216-c7be57c97ab6)
#### [결제]
![스크린샷 2024-11-01 오전 4 55 58](https://github.com/user-attachments/assets/54f935a0-f05c-4013-82a4-f9e743dff75c)
</details>
<br/>

### 결과 분석 및 정리
- 재시도를 설정한 낙관적락에 비해 측정된 시간으로만 비교하면 성능이 더 좋다.
- 하지만, 대용량 트래픽이 발생할 경우 락을 획득하기 위해 대기하는 스레드가 많아져 성능 저하가 발생할 수 있다.
- 한 번만 성공하는게 아닌, 모든 요청이 동시성 제어를 통해 성공되어야 할 경우 낙관적락 보다 적합하다.

### (3) Redis Simple Lock
#### 동작 방식
- `SETNX` 명령어로 락을 획득하고, `DEL` 명령어로 락을 해제한다. 

#### 장점
- 구현이 간단하다. 

#### 단점
- 재시도 로직을 직접 구현해야 한다.  
<br/>
### 정리
- simple lock은 재시도 로직이 없는 낙관적락과 비슷한 방식으로 동작한다.
- spin lock에서 simple lock기반으로 재시도 로직을 구현하기 때문에, simple lock에 대한 테스트는 따로 하지 않는다.

### (4) Redis Spin Lock
#### 동작 방식
- Lock 획득 실패 시, 일정 시간/횟수 동안 Lock 획득을 재시도한다.

#### 장점
- 구현이 간단하다.

#### 단점
- 대용량 트래픽 발생 시 Redis 서버에 부하가 많이 가며, 성능 저하가 발생할 수 있다.
<br/>
<br/>

<details>
  <summary>테스트 결과</summary>

#### [좌석 예약]
![스크린샷 2024-11-01 오전 4 58 07](https://github.com/user-attachments/assets/9ada4548-8fc2-4f5f-b541-666b50695a75)
#### [포인트 충전]
![스크린샷 2024-11-01 오전 4 57 37](https://github.com/user-attachments/assets/5385415f-bd84-4cf1-b8d1-32a9ed9b8649)
#### [포인트 사용]
![스크린샷 2024-11-01 오전 4 59 12](https://github.com/user-attachments/assets/3d5be474-e9be-4b25-9ffb-1521d2e0da06)
#### [결제]
![스크린샷 2024-11-01 오전 4 58 40](https://github.com/user-attachments/assets/85cda12d-4fcd-40e1-b62e-8e75f2b48f29)
</details>
<br/>

### 결과 분석 및 정리
- 모든 시나리오에서 성능이 가장 안좋다고 할 수 있다.
- 대용량 트래픽 발생 시 지속적인 재시도를 통해 Redis 서버에 부하가 많이 가며, 성능 저하가 발생할 수 있다.
- 꼭 써야 한다면, 재시도 횟수와 재시도 시간을 적절히 설정하여 성능을 최적화할 수 있다.

### (5) Redis Pub/Sub Lock
#### 동작 방식
- Redisson의 Pub/Sub 기능을 활용하여 락을 획득하고 해제한다.

#### 장점
- Pub/Sub 기반으로 동작하기 때문에 재시도 로직이 필요 없으므로 redis 서버에 부하가 적다.

#### 단점
- Pub/Sub 메시징 시스템을 사용함으로써 추가적인 CPU 및 메모리 자원을 소모한다.
<br/>
<br/>

<details>
  <summary>테스트 결과</summary>

#### [좌석 예약]
![스크린샷 2024-11-01 오전 5 00 23](https://github.com/user-attachments/assets/5fd8abcd-63e0-4b37-90fb-7ae837538752)
#### [포인트 충전]
![스크린샷 2024-11-01 오전 4 59 57](https://github.com/user-attachments/assets/3685c8a0-afc1-42eb-8c22-6b5306d8c61b)
#### [포인트 사용]
![스크린샷 2024-11-01 오전 5 01 17](https://github.com/user-attachments/assets/63c046a7-d9dc-41dd-9790-c06a6e1d3e2c)
#### [결제]
![스크린샷 2024-11-01 오전 5 00 50](https://github.com/user-attachments/assets/56f140e4-2e8a-449e-9297-06b3182dd39d)
</details>
<br/>

### 결과 분석 및 정리
- pub/sub 구조로 인해 spin lock과 같은 재시도 로직이 필요 없어 spin lock에 비해 성능이 좋다.
- 하지만, pub/sub 메시징 시스템을 사용함으로써 추가적인 CPU 및 메모리 자원을 소모하고, 네트워크 단절 혹은 장애 발생 시 메시지가 소실 될 수 있다.
- 또한 waitTime, leaseTime을 적절히 설정하지 않으면 락을 획득하지 못하는 경우가 발생할 수 있다.
<br/>

### (6) kafka
#### 동작 방식
- 특정 데이터에 대한 접근 요청을 동일한 파티션에 보내서 한 번에 하나의 Consumer만 접근하도록 한다.<br/>
  동시성을 제어한다기보다, 동시성 문제를 만들지 않는 방법이다.

#### 장점
- 요청을 순차적으로 처리해, 데이터 일관성을 유지하며, 성능이 좋다.

#### 단점
- 구현의 난이도와 복잡성이 높다.
<br/>


## 3. 동시성 제어 방식 비교
| 방식               | 구현 복잡도 | 성능                        | 효율성                       |
|------------------|--------|---------------------------|---------------------------|
| Optimistic Lock  | 중      | 하<br/>(1번만 성공 보장해야할 경우 상) | 하<br/>(1번만 성공 보장해야할 경우 상) |
| Pessimistic Lock | 하      | 중                         | 중                         |
| Simple Lock      | 하      | 중                         | 중                         |
| Spin Lock        | 중      | 하                         | 하                         |
| Pub/Sub Lock     | 중      | 중                         | 중                         |
| Kafka            | 상      | 상                         | 상                         |

## 4. 결론
낙관적 락의 경우 잦은 재시도로 인해, 시스템 전반에 성능을 저하시킬 수 있다. 그러나 1번의 요청만 처리해도 될 경우 비관적 락에 비해 스레드의 대기가 필요없기 때문에, 성능상 이점을 가져갈 수 있다.
비관적 락의 경우, 락을 획득하기 위해 대기하는 스레드가 많아지면 성능 저하가 발생할 수 있다. 하지만, 모든 요청이 동시성 제어를 통해 처리되어야 할 경우에는 적합하다.
Redis를 사용한 락은 분산환경일 경우 사용해야 하며, 데이터베이스의 부하를 줄여줄 수 있따. 하지만 클러스터링을 하지 않은 채, 단일로 사용한다면, SPOF(단일 장애점)이 될 수 있다.
Kafka는 동시성을 제어한다기 보다, 동시성 문제를 야기하는 원인을 근본적으로 해결한다고 할 수 있다. 동시에 여러 요청이 들어오더라도, 요청을 순차적으로 처리하기 때문이다.
성능은 가장 좋겠지만, 구현의 난이도와 복잡성, 러닝 커브 등이 높아 이번 분석에서는 제외했다.
<br/>

문제를 해결하기 위해 어떤 기술을 택하기 위해서는 다양한 관점에서 접근해야 된다고 생각한다. 그런의미에서 현재 시스템에 Redis를 캐싱용도로 사용할 예정이고, 
어느정도의 트래픽이 발생한다는 가정을 내리고, 각 시나리오에 맞는 동시성 제어 기술을 택했다.<br/>

[콘서트 좌석 예약] 같은 경우는 충돌이 빈번하게 발생하기 때문에 Redis Pub/Sub Lock을 적용해 데이터베이스의 부하를 줄일 수 있다.
[포인트 충전, 포인트 사용, 결제] 같은 경우는 충돌이 빈번하게 발생하지 않기 때문에 성능(시간이 짧게 걸린)이 좋은 비관적 락을 적용할 예정이다.